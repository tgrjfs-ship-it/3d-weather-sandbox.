<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Navier-Stokes Fluid Simulation</title>
<style>
  body {
    margin: 0;
    background: black;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: flex-start;
    min-height: 100vh;
    font-family: monospace;
    color: white;
  }
  canvas {
    border: 4px solid #333;
    border-radius: 12px;
    touch-action: none;
    max-width: 100%;
    height: auto;
  }
  .status {
    margin: 0.5rem 0;
    background: #111;
    color: #0f0;
    padding: 0.5rem 1rem;
    border-radius: 6px;
  }
  .controls {
    display: flex;
    flex-direction: column;
    align-items: flex-start;
    margin-bottom: 1rem;
    gap: 0.5rem;
    width: 100%;
  }
  .controls .row { display:flex; gap:0.5rem; align-items:center; flex-wrap: wrap; }
  .toggle-btn {
    background: linear-gradient(180deg,#2b2b2b,#1a1a1a);
    color:#ffdfff; border:1px solid #5a3b7a; padding:6px 10px; border-radius:10px;
    cursor:pointer; box-shadow: 0 3px 8px rgba(0,0,0,0.6);
  }
  .toggle-btn.on { background: linear-gradient(180deg,#6a3bd4,#3a1f7a); color:#fff; }

  button, .toggle-btn {
    font-family: monospace;
    font-size: 14px;
  }
  input[type="range"], .control-slider {
    accent-color: #7a4bd6;
    height: 28px;
    width: 100%;
    max-width: 320px;
  }
  #loadingOverlay { font-size: 18px; }
  #glOverlay { position:absolute; left:0; top:0; pointer-events:none; border-radius:12px; }
  #loadingOverlay {
    position:fixed; inset:0; display:none; align-items:center; justify-content:center;
    background:rgba(10,10,10,0.7); color:#fff; font-family:monospace; z-index:40;
  }

  /* Panel for merged UI */
  .panel {
    width: 100%;
    max-width: 680px;
    box-sizing: border-box;
    padding: 10px 12px;
    margin: 10px;
    border-radius: 12px;
    background: #0b0b0b;
    border: 1px solid #222;
    box-shadow: 0 6px 16px rgba(0,0,0,0.5);
  }
  .panel h1 {
    margin: 0 0 6px 0;
    font-size: 18px;
    color: #ddd;
  }
  .panel .buttons { display:flex; gap:8px; flex-wrap: wrap; }

  /* Mobile-friendly adjustments */
  @media (max-width: 768px) {
    .panel { margin: 8px; padding: 10px; }
    .controls label { font-size: 13px; }
    .controls .row label { font-size: 13px; }
    .panel .buttons button, .panel .buttons .toggle-btn { flex: 1 1 auto; }
  }
</style>
</head>
<body>

<div class="panel">
  <h1>Navier-Stokes Fluid</h1>
  <div class="status" id="status">Starting...</div>

  <div class="controls" id="uiPanel">
    <label>Brush Intensity: <span id="intensityVal">100</span></label>
    <input type="range" id="brushIntensity" min="20" max="500" value="100">
    
    <label>Brush Size: <span id="sizeVal">1</span></label>
    <input type="range" id="brushSize" min="1" max="50" value="1">
  
    <div class="buttons">
      <button id="pauseBtn">Pause</button>
      <button id="curlToggle" class="toggle-btn">Curl: Off</button>
    </div>

    <label>Resolution:
      <select id="resolutionSelect">
        <option value="low">Low</option>
        <option value="med" selected>Medium</option>
        <option value="high">High</option>
      </select>
    </label>

    <div class="row">
      <button id="resetBtn">Reset Simulation</button>
      <button id="shaderToggle" class="toggle-btn">Shader: Off</button>
      <button id="fullscreenBtn" class="toggle-btn">Fullscreen Canvas</button>
      <button id="fullscreenLandscapeBtn" class="toggle-btn">Fullscreen Landscape</button>
    </div>

    <div class="row" style="align-items:center; gap:0.6rem;">
      <label style="font-size:13px;">Zoom</label>
      <input id="zoomSlider" type="range" min="0.7" max="2" step="0.01" value="1">
      <label style="font-size:13px;">Camera X</label>
      <input id="camXSlider" type="range" min="0" max="100" step="1" value="0">
    </div>
    <div class="row" style="align-items:center; gap:0.6rem;">
      <label style="font-size:13px;">View Width</label>
      <input id="viewW" type="range" min="240" max="768" step="8" value="512">
      <label style="font-size:13px;">View Height</label>
      <input id="viewH" type="range" min="240" max="768" step="8" value="512">
    </div>

    <div id="shaderControls" style="display:none; flex-direction:column; gap:6px;">
      <label>Shader Intensity: <span id="shaderIntVal">0.6</span></label>
      <input class="control-slider" id="shaderIntensity" type="range" min="0" max="1" step="0.01" value="0.6">
      <label>Noise Scale: <span id="noiseVal">3.0</span></label>
      <input class="control-slider" id="noiseScale" type="range" min="0.5" max="8" step="0.1" value="3">
    </div>

    <label>Max Droplets: <span id="maxDropletsVal">400</span></label>
    <input id="maxDroplets" type="range" min="100" max="1200" step="10" value="400">

    <label>Base Temp (°C): <span id="baseTempVal">15</span></label>
    <input id="baseTemp" type="range" min="-20" max="40" step="1" value="15">

    <div class="row" style="align-items:center; gap:0.6rem;">
      <label style="font-size:13px;">Disable Max Droplet Cap</label>
      <input type="checkbox" id="disableMaxToggle" />
      <span id="disableWarning" style="display:none; color:#ffcc66; font-size:13px; margin-left:0.5rem;">
        Warning: Are you sure you want to turning the maximum droplets off? turning this off can causes performance drops
      </span>
    </div>
  </div>
</div>

<canvas id="fluidCanvas"></canvas>
<canvas id="glOverlay" width="0" height="0" style="z-index:20;"></canvas>
<div id="loadingOverlay"><div id="loadingText">Loading shader...</div></div>

<p style="margin:8px 0;">Jos Stam's Stable Fluids Algorithm</p>

<script>
const canvas = document.getElementById('fluidCanvas');
const ctx = canvas.getContext('2d');
const statusEl = document.getElementById('status');

const SIZE = Math.min(512, window.innerWidth - 40);
canvas.width = SIZE;
canvas.height = SIZE;

// New shadow-ray settings
let shadowIntensity = 0.28; // kept for subtle flash intensity (no shadow rays)

// replace fixed size/grid constants with dynamic variables
let N; // grid resolution (cells per side)
let CELL; // pixel size per cell

// grid arrays (will be created by initGrid)
let density, vx, vy, density0, vx0, vy0, temperature;

// Add global particle/lightning and timing state to avoid ReferenceErrors
let particles = [];
let lightnings = [];
let lastLightningTime = 0;
let lightningCooldown = 4000; // ms cooldown between strikes
let screenShake = 0;

// Audio for lightning (preloaded)
const lightningSounds = [];
let lightningSoundBuffersLoaded = false;
// list of audio files to load (these assets are added separately)
const lightningFiles = [
  'lightning1.mp3', 'lightning2.mp3', 'lightning3.mp3',
  'lightning4.mp3', 'lightning5.mp3', 'lightning6.mp3'
];
function preloadLightningSounds(){
  return new Promise((resolve) => {
    let loaded = 0;
    if (lightningFiles.length === 0) { lightningSoundBuffersLoaded = true; resolve(); return; }
    for(const f of lightningFiles){
      const a = new Audio(f);
      a.preload = 'auto';
      a.addEventListener('canplaythrough', () => {
        loaded++; if (loaded >= lightningFiles.length) { lightningSoundBuffersLoaded = true; resolve(); }
      }, { once:true });
      a.addEventListener('error', () => {
        // count errors as "loaded" to avoid blocking startup
        loaded++; if (loaded >= lightningFiles.length) { lightningSoundBuffersLoaded = true; resolve(); }
      }, { once:true });
      lightningSounds.push(a);
    }
    // fallback timeout to avoid hanging if events don't fire
    setTimeout(() => { if (!lightningSoundBuffersLoaded) { lightningSoundBuffersLoaded = true; resolve(); } }, 2500);
  });
}
preloadLightningSounds();

// Temperature and precipitation controls (declare before initGrid so initGrid can use baseTemperature)
let maxDroplets = 400;
let baseTemperature = 15; // degrees Celsius
let terrain = []; let water = []; // 1D terrain & water
// FPS / framerate cap
let fps = 0;
let fpsSmoothed = 0;
let fpsLastTime = performance.now();
let framesThisSecond = 0;
let fpsDisplayEl = null;
let maxFps = 60;
let maxFpsSliderEl = null;
let maxFpsValEl = null;

// Initialize default grid
initGrid('med');

// Pause state
let brushIntensity = 100;
let brushSize = 1;
let running = true;
let curlEnabled = false; // toggle for curl force
let cameraX = 0, cameraY = 0, zoom = 1;

// Initialize grid based on selected resolution
function initGrid(res='med') {
  if (res === 'low') N = 96;
  else if (res === 'high') N = 256;
  else N = 180; // med
  CELL = SIZE / N;

  density = new Array(N * N).fill(0);
  vx = new Array(N * N).fill(0);
  vy = new Array(N * N).fill(0);
  density0 = new Array(N * N).fill(0);
  vx0 = new Array(N * N).fill(0);
  vy0 = new Array(N * N).fill(0);

  // Initialize per-cell temperature with small noise around baseTemperature
  temperature = new Array(N * N);
  for (let j = 0; j < N; j++) {
    for (let i = 0; i < N; i++) {
      const idx = i + j * N;
      // gentle vertical gradient (colder aloft): higher j => slightly warmer (surface)
      const grad = (j / N) * 4.0; // up to ~4°C variation
      temperature[idx] = baseTemperature + grad + (Math.random() - 0.5) * 2.2;
    }
  }
  // generate 1D terrain (length N) and water levels
  terrain = new Array(N);
  water = new Array(N).fill(0);
  for (let i = 0; i < N; i++) {
    const t = i / N;
    const base = 24 + 12*Math.sin(t*Math.PI*2.0);
    const bumps = 10*Math.sin(t*8.0) + 6*Math.sin(t*3.3);
    terrain[i] = Math.max(12, base + bumps + (Math.random()-0.5)*6);
  }
}

// Update IX to use dynamic N (replace previous IX)
const IX = (x, y) => {
  x = Math.max(0, Math.min(N-1, Math.floor(x)));
  y = Math.max(0, Math.min(N-1, Math.floor(y)));
  return x + y * N;
};

// Diffuse, Advect, Project (same as before)
function diffuse(b, x, x0, diff, dt, iter = 8) {
  const a = dt * diff * (N - 2) * (N - 2);
  for (let k = 0; k < iter; k++) {
    for (let i = 1; i < N - 1; i++) {
      for (let j = 1; j < N - 1; j++) {
        x[IX(i,j)] = (x0[IX(i,j)] + a * (
          x[IX(i+1,j)] + x[IX(i-1,j)] +
          x[IX(i,j+1)] + x[IX(i,j-1)]
        )) / (1 + 4*a);
      }
    }
  }
}

function advect(b, d, d0, vx, vy, dt) {
  const dt0 = dt * (N - 2);
  for (let i = 1; i < N - 1; i++) {
    for (let j = 1; j < N - 1; j++) {
      let x = i - dt0 * vx[IX(i,j)];
      let y = j - dt0 * vy[IX(i,j)];
      x = Math.max(0.5, Math.min(N - 1.5, x));
      y = Math.max(0.5, Math.min(N - 1.5, y));
      const i0 = Math.floor(x), i1 = i0 + 1;
      const j0 = Math.floor(y), j1 = j0 + 1;
      const s1 = x - i0, s0 = 1 - s1;
      const t1 = y - j0, t0 = 1 - t1;
      d[IX(i,j)] = s0 * (t0 * d0[IX(i0,j0)] + t1 * d0[IX(i0,j1)]) +
                   s1 * (t0 * d0[IX(i1,j0)] + t1 * d0[IX(i1,j1)]);
    }
  }
}

function project(vx, vy, p, div, iter = 8) {
  for (let i = 1; i < N - 1; i++) {
    for (let j = 1; j < N - 1; j++) {
      div[IX(i,j)] = -0.5 * (
        vx[IX(i+1,j)] - vx[IX(i-1,j)] +
        vy[IX(i,j+1)] - vy[IX(i,j-1)]
      ) / N;
      p[IX(i,j)] = 0;
    }
  }
  for (let k = 0; k < iter; k++) {
    for (let i = 1; i < N - 1; i++) {
      for (let j = 1; j < N - 1; j++) {
        p[IX(i,j)] = (div[IX(i,j)] + 
          p[IX(i+1,j)] + p[IX(i-1,j)] +
          p[IX(i,j+1)] + p[IX(i,j-1)]
        ) / 4;
      }
    }
  }
  for (let i = 1; i < N - 1; i++) {
    for (let j = 1; j < N - 1; j++) {
      vx[IX(i,j)] -= 0.5 * N * (p[IX(i+1,j)] - p[IX(i-1,j)]);
      vy[IX(i,j)] -= 0.5 * N * (p[IX(i,j+1)] - p[IX(i,j-1)]);
    }
  }
}

// Step simulation
function step() {
  diffuse(1, vx0, vx, 0.00001, 0.1);
  diffuse(2, vy0, vy, 0.00001, 0.1);
  project(vx0, vy0, vx, vy);
  advect(1, vx, vx0, vx0, vy0, 0.1);
  advect(2, vy, vy0, vx0, vy0, 0.1);
  project(vx, vy, vx0, vy0);

  diffuse(0, density0, density, 0.00001, 0.1);
  advect(0, density, density0, vx, vy, 0.1);

  const temp0 = new Array(N * N);
  for (let i=0;i<N*N;i++) temp0[i] = temperature[i];
  advect(0, temperature, temp0, vx, vy, 0.05);

  for (let i = 2; i < N-2; i++) {
    for (let j = 2; j < N-2; j++) {
      const idx = IX(i,j);
      const d = density[idx];
      const dNorm = Math.max(0, Math.min(1, d / 500));
      const localTemp = temperature[idx];

      const rainBias = Math.max(0.08, 0.18 - (localTemp - 5) * 0.006);
      const mistBias = Math.max(0.02, 0.03 + (localTemp - 10) * 0.006);

      if (d > 12 && Math.random() < rainBias * dNorm) {
        particles.push({
          x: i * CELL + Math.random() * CELL,
          y: j * CELL + Math.random() * CELL,
          vx: vx[idx]*0.6 + (Math.random()-0.5)*0.6,
          vy: vy[idx]*0.4 + 1.2 + Math.random()*0.8,
          life: 1,
          size: 1.2 + Math.random()*1.8,
          type: 'rain'
        });
        density[idx] = Math.max(0, density[idx] - 18 * dNorm);
      }
      if (d > 80 && Math.random() < mistBias * dNorm) {
        particles.push({
          x: i * CELL + Math.random() * CELL,
          y: j * CELL + Math.random() * CELL,
          vx: vx[idx]*0.4 + (Math.random()-0.5)*0.6,
          vy: vy[idx]*0.2 + -0.2 - Math.random()*0.6,
          life: 1,
          size: 4 + Math.random()*6,
          type: 'mist'
        });
        density[idx] = Math.max(0, density[idx] - 8 * dNorm);
      }

      // CG Lightning
      if (d > 220) {
        const now = performance.now();
        if (now - lastLightningTime > lightningCooldown && Math.random() < 0.02 * dNorm) {
          createLightning(i*CELL, j*CELL);
          lastLightningTime = now;
        }
      }

      // IC Lightning: denser clouds, higher chance but smaller flash; independent cooldown
      if (d > 160 && Math.random() < 0.015 * dNorm) {
        createICLightning(i*CELL, j*CELL);
      }
    }
  }

  for (let p of particles) {
    if (p.type === 'mist') {
      const gi = Math.max(0, Math.min(N-1, Math.floor(p.x / CELL)));
      const gj = Math.max(0, Math.min(N-1, Math.floor(p.y / CELL)));
      const gidx = IX(gi, gj);
      const localTemp = temperature[gidx];
      const localD = density[gidx];
      if (localTemp < 5 && localD > 180) {
        const coldFactor = Math.min(1, (5 - localTemp) / 10);
        const densFactor = Math.min(1, (localD - 180) / 320);
        if (Math.random() < 0.06 * coldFactor * densFactor) {
          p.type = 'rain';
          p.size = 1.6 + Math.random()*1.2;
          p.vy = 1.2 + Math.random()*0.8;
        }
      }
    }
  }

  // Update particles with boundary safety
  particles = particles.flatMap(p => {
    const gi = Math.max(0, Math.min(N-1, Math.floor(p.x / CELL)));
    const gj = Math.max(0, Math.min(N-1, Math.floor(p.y / CELL)));
    const gidx = IX(gi, gj);
    const localVx = vx[gidx] || 0;
    const localVy = vy[gidx] || 0;

    if(p.type==='rain'){
      p.x += p.vx*0.6 + localVx * 0.9;
      p.y += p.vy + localVy * 0.9;
      p.vy += 0.45;
      p.vx = (p.vx + localVx*0.2) * 0.995;
      p.life -= 0.01;
      // Boundary clamp; remove if outside
      if (p.x < 0 || p.x > SIZE || p.y < 0) return null;

      if(p.y > SIZE - 6 || p.life <= 0){
        const wi = Math.max(0, Math.min(N-1, Math.floor(p.x / CELL)));
        water[wi] = (water[wi] || 0) + 0.6;
        const splashes = [];
        if (p.y > SIZE - 6) {
          const count = 2 + Math.floor(Math.random()*3);
          for(let s=0;s<count;s++){
            splashes.push({ x: Math.max(0, Math.min(SIZE, p.x + (Math.random()-0.5)*6)), y: SIZE - 2, vx: (Math.random()-0.5)*2, vy: -1.2 - Math.random()*1.2, life: 0.25 + Math.random()*0.25, size: 0.8+Math.random()*1.2, type: 'splash' });
          }
        }
        return splashes;
      }
      return p;
    }
    if(p.type==='mist'){
      p.x += p.vx*0.15 + localVx * 0.8;
      p.y += p.vy*0.15 + localVy * 0.8;
      p.vy -= 0.01;
      p.vx = (p.vx + localVx*0.1) * 0.995;
      p.life -= 0.006;
      p.size *= 1.005;
      if (p.x < 0 || p.x > SIZE || p.y < 0 || p.y > SIZE) return null;
      return p;
    }
    if(p.type==='splash'){
      p.x += p.vx + localVx * 0.25;
      p.y += p.vy + localVy * 0.25;
      p.vy += 0.25;
      p.vx *= 0.9;
      p.life -= 0.02;
      if (p.x < 0 || p.x > SIZE || p.y < 0 || p.y > SIZE) return null;
      return p;
    }
    return null;
  }).filter(Boolean);

  if (!disableMaxDropletCap && particles.length > maxDroplets) {
    particles.splice(0, particles.length - maxDroplets);
  }

  for(let i=1;i<N-1;i++){
    const diffusion = 0.15*(water[i-1]+water[i+1]-2*water[i]);
    water[i] += diffusion;
    water[i] = Math.max(0, water[i] - 0.004 - Math.max(0, (terrain[i]-18))*0.0002);
  }

  lightnings = lightnings.filter(l=>{ l.life-=0.06; l.flicker=Math.random(); return l.life>0; });
  if(screenShake>0){screenShake*=0.88;if(screenShake<0.1) screenShake=0;}
  for(let i=0;i<N*N;i++) density[i]*=0.995;
}

// Add fluid
function addFluid(x, y, dx, dy) {
  if(!running) return; // prevent adding while paused
  const i=Math.floor(x/CELL), j=Math.floor(y/CELL);
  const speed = Math.sqrt(dx*dx + dy*dy);
  const maxSpeed = 4;
  if(speed>maxSpeed){dx=(dx/speed)*maxSpeed; dy=(dy/speed)*maxSpeed;}
  dx *= 0.5; dy *= 0.5;

  for(let di=-brushSize;di<=brushSize;di++){
    for(let dj=-brushSize;dj<=brushSize;dj++){
      const idx = IX(i+di,j+dj);
      const dist = Math.sqrt(di*di + dj*dj);
      if(dist>brushSize) continue;
      const falloff = 1 - dist/brushSize;
      density[idx] = Math.min(density[idx]+brushIntensity*falloff,500);
      vx[idx] += dx*falloff; vy[idx] += dy*falloff;
      // apply curl (rotational) force when enabled
      if (curlEnabled) {
        const curlStrength = 0.28; // tweakable constant
        vx[idx] += -dj * curlStrength * falloff;
        vy[idx] += di * curlStrength * falloff;
      }
      vx[idx] = Math.max(-maxSpeed, Math.min(maxSpeed, vx[idx]));
      vy[idx] = Math.max(-maxSpeed, Math.min(maxSpeed, vy[idx]));
    }
  }
}

// Lightning creation (same as before)
function createLightning(x,y){
  // Build a more compact, natural-looking bolt:
  const segments = [];
  let cx = x, cy = y;
  const targetY = SIZE;
  const baseStep = 8;
  while (cy < targetY) {
    const nextY = cy + baseStep + Math.random() * 10;
    const nextX = cx + (Math.random() - 0.5) * 18;
    segments.push({ x1: cx, y1: cy, x2: nextX, y2: nextY, thickness: 1.6 + Math.random() * 0.8 });

    if (Math.random() < 0.28 && nextY < targetY - 30) {
      const branchDir = Math.random() < 0.5 ? -1 : 1;
      let bx = nextX, by = nextY;
      const branchLength = 1 + Math.floor(Math.random() * 3);
      for (let b = 0; b < branchLength; b++) {
        const nextBx = bx + branchDir * (6 + Math.random() * 10);
        const nextBy = by + 6 + Math.random() * 10;
        const thickness = Math.max(0.6, 0.9 - b * 0.18);
        segments.push({ x1: bx, y1: by, x2: nextBx, y2: nextBy, thickness: thickness });
        bx = nextBx; by = nextBy;
        if (Math.random() < 0.12 && by < targetY - 10) {
          const subDir = Math.random() < 0.5 ? -1 : 1;
          segments.push({
            x1: bx, y1: by,
            x2: bx + subDir * (4 + Math.random() * 6),
            y2: by + 4 + Math.random() * 6,
            thickness: 0.5
          });
        }
      }
    }
    cx = nextX; cy = nextY;
  }

  // Add the bolt with slightly reduced flash to keep it from overpowering the scene
  const shadowStreaks = [];
  lightnings.push({ segments, life: 1.0, flicker: Math.random(), flash: 1.0, shadowStreaks });
  // shorter, crisper screen shake
  screenShake = Math.min(14, screenShake + 6);

  // Play random lightning sound if loaded
  playLightningSound();
}

// IC lightning type creator (in-cloud lightning)
function createICLightning(x, y){
  const segments = [];
  let cx = x, cy = y;
  // IC lightning meanders within cloud: short, horizontal-biased segments
  const maxLen = 120 + Math.random()*80;
  let length = 0;
  for(let s=0; s<60 && length < maxLen; s++){
    const stepX = (Math.random()-0.5) * 28; // more horizontal drift
    const stepY = (Math.random()-0.5) * 18; // limited vertical drift
    const nx = Math.max(12, Math.min(SIZE-12, cx + stepX));
    const ny = Math.max(12, Math.min(SIZE-120, cy + stepY));
    const thick = 1.0 + Math.random()*0.6;
    segments.push({ x1: cx, y1: cy, x2: nx, y2: ny, thickness: thick });
    length += Math.hypot(nx-cx, ny-cy);
    cx = nx; cy = ny;
  }
  lightnings.push({ segments, life: 0.9, flicker: Math.random(), flash: 0.4, type: 'ic' });
  playLightningSound();
}

// Play a random lightning sound with slight pitch/volume randomization
function playLightningSound(){
  if(!lightningSounds.length) return;
  try {
    const idx = Math.floor(Math.random() * lightningSounds.length);
    const src = lightningSounds[idx];
    // clone to allow overlapping plays
    const audio = src.cloneNode(true);
    audio.volume = 0.6 + Math.random() * 0.3; // 0.6-0.9
    // slight playbackRate variation for diversity
    audio.playbackRate = 0.9 + Math.random() * 0.25;
    audio.currentTime = 0;
    audio.play().catch(()=>{/* ignore autoplay errors */});
  } catch(e){
    // fail silently
    console.warn('playLightningSound failed', e);
  }
}

// Render
function render(){
  ctx.save();
  ctx.scale(zoom, zoom);
  ctx.translate(-cameraX, -cameraY);
  ctx.fillStyle='rgba(170,210,240,0.95)';
  ctx.fillRect(0,0,SIZE,SIZE);

  for(let i=0;i<N;i++){
    for(let j=0;j<N;j++){
      const d=density[IX(i,j)];
      if(d>0.5){
        const alpha=Math.min(d/200,0.9);
        ctx.fillStyle=`rgba(80,90,100,${alpha})`;
        ctx.fillRect(i*CELL,j*CELL,CELL+1,CELL+1);
      }
    }
  }

  // Particles (rain, mist, splashes)
  particles.forEach(p=>{
    if(p.type==='rain'){
      const alpha=Math.max(0, Math.min(1, p.life*0.9));
      ctx.strokeStyle=`rgba(200,220,255,${alpha})`;
      ctx.lineWidth = Math.max(1, p.size*0.8);
      ctx.lineCap='round';
      ctx.beginPath();
      ctx.moveTo(p.x, p.y);
      ctx.lineTo(p.x - p.vx*2.5, p.y - p.vy*0.15);
      ctx.stroke();
      // small bright head
      ctx.fillStyle=`rgba(220,240,255,${alpha})`; ctx.beginPath();
      ctx.ellipse(p.x - p.vx*0.6, p.y - p.vy*0.05, p.size*0.6, p.size*0.9, 0, 0, Math.PI*2); ctx.fill();
    } else if(p.type==='mist'){
      const alpha = Math.max(0, Math.min(0.35, p.life*0.35));
      const gradient=ctx.createRadialGradient(p.x,p.y,0,p.x,p.y,p.size);
      gradient.addColorStop(0,`rgba(220,230,240,${alpha})`);
      gradient.addColorStop(0.6,`rgba(200,215,230,${alpha*0.6})`);
      gradient.addColorStop(1,`rgba(180,200,220,0)`);
      ctx.fillStyle=gradient; ctx.beginPath(); ctx.arc(p.x,p.y,p.size,0,Math.PI*2); ctx.fill();
    } else if(p.type==='splash'){
      const alpha = Math.max(0, p.life*0.9);
      ctx.fillStyle = `rgba(210,230,250,${alpha})`;
      ctx.beginPath(); ctx.arc(p.x, p.y, p.size, 0, Math.PI*2); ctx.fill();
    }
  });

  // Lightning: purple glow, layered strokes, and screen flash
  lightnings.forEach(l=>{
    const lifeAlpha = Math.max(0, l.life);
    const pulse = 0.6 + l.flicker*0.6;
    const alpha = Math.min(1, lifeAlpha * pulse);

    // Subtle flash only for CG
    if(l.type==='cg' && l.life > 0.85){
      ctx.save();
      ctx.globalCompositeOperation = 'screen';
      ctx.fillStyle = `rgba(200,160,255,${0.18 * (l.flash||1)})`;
      ctx.fillRect(0,0,SIZE,SIZE);
      ctx.restore();
    }

    // Color scheme selection
    const outerColor = (l.type==='ic') ? `rgba(150,190,255,${0.16*alpha})` : `rgba(160,90,255,${0.18*alpha})`;
    const midShadow = (l.type==='ic') ? `rgba(180,210,255,${0.5*alpha})` : `rgba(200,140,255,${0.6*alpha})`;
    const coreColor = (l.type==='ic') ? `rgba(220,240,255,${0.9*alpha})` : `rgba(240,220,255,${0.95*alpha})`;

    // Outer glow
    ctx.save();
    ctx.globalCompositeOperation = 'lighter';
    ctx.shadowBlur = 30 * (0.6 + lifeAlpha*0.6);
    ctx.shadowColor = midShadow;
    l.segments.forEach(seg=>{
      ctx.strokeStyle = outerColor;
      ctx.lineWidth = seg.thickness*8;
      ctx.beginPath(); ctx.moveTo(seg.x1,seg.y1); ctx.lineTo(seg.x2,seg.y2); ctx.stroke();
    });
    ctx.restore();

    // Mid glow
    ctx.save();
    ctx.globalCompositeOperation = 'lighter';
    ctx.shadowBlur = 14 * (0.8 + lifeAlpha*0.8);
    ctx.shadowColor = midShadow;
    l.segments.forEach(seg=>{
      ctx.strokeStyle = (l.type==='ic') ? `rgba(190,220,255,${0.3*alpha})` : `rgba(200,130,255,${0.36*alpha})`;
      ctx.lineWidth = seg.thickness*4;
      ctx.beginPath(); ctx.moveTo(seg.x1,seg.y1); ctx.lineTo(seg.x2,seg.y2); ctx.stroke();
    });
    ctx.restore();

    // Core lines
    ctx.save();
    ctx.globalCompositeOperation = 'lighter';
    l.segments.forEach(seg=>{
      ctx.strokeStyle = coreColor;
      ctx.lineWidth = Math.max(1, seg.thickness*1.1);
      ctx.shadowBlur = 5;
      ctx.shadowColor = coreColor;
      ctx.beginPath(); ctx.moveTo(seg.x1,seg.y1); ctx.lineTo(seg.x2,seg.y2); ctx.stroke();
    });
    ctx.restore();
  });

  ctx.shadowBlur = 0;

  ctx.save();
  ctx.translate(0, SIZE);
  ctx.scale(1, -1);
  ctx.beginPath();
  ctx.moveTo(0, 0);
  for(let i=0;i<N;i++){ ctx.lineTo(i*CELL, terrain[i]); }
  ctx.lineTo(SIZE, 0); ctx.closePath();
  ctx.fillStyle = '#393e46';
  ctx.fill();
  ctx.beginPath();
  for(let i=0;i<N;i++){ ctx.lineTo(i*CELL, terrain[i] + water[i]); }
  ctx.lineWidth = 2; ctx.strokeStyle = 'rgba(80,140,220,0.9)';
  ctx.stroke();
  ctx.restore();

  ctx.restore();
}

// Initial random fluids
for(let i=0;i<8;i++){
  const x=Math.random()*N; const y=Math.random()*N;
  density[IX(x,y)]=500;
  vx[IX(x,y)]=(Math.random()-0.5)*20;
  vy[IX(x,y)]=(Math.random()-0.5)*20;
}

statusEl.textContent='✓ Touch screen or drag to add fluid!';

// Input handling
let touching=false,lastX=-1,lastY=-1;
function getPos(e){
  const rect=canvas.getBoundingClientRect();
  const scaleX=SIZE/rect.width; const scaleY=SIZE/rect.height;
  if(e.touches && e.touches[0]) return {x:(e.touches[0].clientX-rect.left)*scaleX, y:(e.touches[0].clientY-rect.top)*scaleY};
  return {x:(e.clientX-rect.left)*scaleX, y:(e.clientY-rect.top)*scaleY};
}
function onStart(e){e.preventDefault(); touching=true; const pos=getPos(e); lastX=pos.x; lastY=pos.y; addFluid(pos.x,pos.y,0,0);}
function onMove(e){e.preventDefault(); if(!touching) return; const pos=getPos(e); if(lastX>=0){addFluid(pos.x,pos.y,pos.x-lastX,pos.y-lastY);} lastX=pos.x; lastY=pos.y;}
function onEnd(e){e.preventDefault(); touching=false; lastX=lastY=-1;}

canvas.addEventListener('mousemove', onStart);
canvas.addEventListener('mousemove', onMove);
canvas.addEventListener('mouseup', onEnd);
canvas.addEventListener('touchstart', onStart,{passive:false});
canvas.addEventListener('touchmove', onMove,{passive:false});
canvas.addEventListener('touchcancel', onEnd,{passive:false});
canvas.addEventListener('touchend', onEnd,{passive:false});

// Brush controls
const brushIntensitySlider = document.getElementById('brushIntensity');
const brushSizeSlider = document.getElementById('brushSize');
const intensityVal = document.getElementById('intensityVal');
const sizeVal = document.getElementById('sizeVal');
const curlToggle = document.getElementById('curlToggle');

brushIntensitySlider.addEventListener('input', (e) => {
  brushIntensity = parseFloat(e.target.value);
  intensityVal.textContent = brushIntensity;
});

brushSizeSlider.addEventListener('input', (e) => {
  brushSize = parseInt(e.target.value);
  sizeVal.textContent = brushSize;
});

curlToggle.addEventListener('click', () => {
  curlEnabled = !curlEnabled;
  curlToggle.classList.toggle('on', curlEnabled);
  curlToggle.textContent = curlEnabled ? 'Curl: On' : 'Curl: Off';
});

// New UI elements for precipitation control
const maxDropletsSlider = document.getElementById('maxDroplets');
const maxDropletsVal = document.getElementById('maxDropletsVal');
const baseTempSlider = document.getElementById('baseTemp');
const baseTempVal = document.getElementById('baseTempVal');

// New: disable max droplets toggle handling
const disableMaxToggle = document.getElementById('disableMaxToggle');
const disableWarning = document.getElementById('disableWarning');
let disableMaxDropletCap = false;

// effectiveMaxDroplets used when trimming
function effectiveMaxDroplets() {
  return disableMaxDropletCap ? Infinity : maxDroplets;
}

disableMaxToggle.addEventListener('change', (e) => {
  if (e.target.checked) {
    // show warning and require confirmation (small inline confirm)
    disableWarning.style.display = 'inline';
    // ask explicit confirm via window.confirm for clarity
    const ok = confirm("Warning: Are you sure you want to turn the maximum droplets off? Turning this off can cause performance drops.");
    if (!ok) {
      disableMaxToggle.checked = false;
      disableWarning.style.display = 'none';
      disableMaxDropletCap = false;
      return;
    }
    disableMaxDropletCap = true;
    // if disabled, ensure we don't trim particles and inform user
    statusEl.textContent = 'Max droplet cap disabled — monitor performance';
  } else {
    disableWarning.style.display = 'none';
    disableMaxDropletCap = false;
    statusEl.textContent = 'Max droplet cap enabled';
    // if too many particles, trim down to slider value
    if (particles.length > maxDroplets) particles.splice(0, particles.length - maxDroplets);
  }
});

// Pause button
const pauseBtn = document.getElementById('pauseBtn');
pauseBtn.addEventListener('click', () => {
  running = !running;
  pauseBtn.textContent = running ? 'Pause' : 'Resume';
  statusEl.textContent = running ? '✓ Touch screen or drag to add fluid!' : '❚❚ Paused';
  if (running) {
    requestAnimationFrame(animate);
  }
});

// --- Shader overlay variables ---
const glCanvas = document.getElementById('glOverlay');
let gl = null, shaderProgram = null, quadVBO = null;
let shaderActive = false, shaderReady = false;
let shaderUniforms = { time:0, intensity:0.6, noiseScale:3.0, resolution:[SIZE,SIZE] };
const loadingOverlay = document.getElementById('loadingOverlay');

function resizeGlCanvas(){
  glCanvas.width = SIZE; glCanvas.height = SIZE;
  glCanvas.style.width = canvas.style.width; glCanvas.style.height = canvas.style.height;
  shaderUniforms.resolution = [glCanvas.width, glCanvas.height];
  if(gl) gl.viewport(0,0,glCanvas.width,glCanvas.height);
}

resizeGlCanvas();

function showLoading(on, text = 'Loading resources...'){
  loadingOverlay.style.display = on ? 'flex' : 'none';
  const t = document.getElementById('loadingText');
  if(t) t.textContent = text;
}

// Show startup loading overlay until initial assets ready
showLoading(true, 'Loading resources...');
Promise.all([
  // wait for audio preload promise already started above
  (async()=>{ while(!lightningSoundBuffersLoaded){ await new Promise(r=>setTimeout(r,60)); } })()
]).then(()=> {
  // keep overlay a short moment for smoother UX
  setTimeout(()=> showLoading(false), 350);
});

function initWebGLShader(){
  showLoading(true);
  return new Promise((resolve, reject)=>{
    try{
      gl = glCanvas.getContext('webgl', { antialias:true });
      if(!gl) throw new Error('WebGL unavailable');
      // simple fullscreen quad shader (vignette + animated noise + intensity)
      const vs = `
        attribute vec2 aPos; varying vec2 vUv;
        void main(){ vUv = aPos*0.5+0.5; gl_Position = vec4(aPos,0.0,1.0); }
      `;
      const fs = `
        precision mediump float;
        varying vec2 vUv; uniform float time; uniform float intensity; uniform float noiseScale; uniform vec2 resolution;
        // a cheap pseudo-noise
        float hash(vec2 p){ return fract(sin(dot(p,vec2(127.1,311.7))) * 43758.5453123); }
        float noise(vec2 p){
          vec2 i = floor(p); vec2 f = fract(p);
          float a = hash(i); float b = hash(i+vec2(1.0,0.0)); float c = hash(i+vec2(0.0,1.0)); float d = hash(i+vec2(1.0,1.0));
          vec2 u = f*f*(3.0-2.0*f);
          return mix(a,b,u.x) + (c-a)*u.y*(1.0-u.x) + (d-b)*u.x*u.y;
        }
        void main(){
          vec2 uv = vUv;
          float n = noise(uv * noiseScale + vec2(time*0.02));
          float vig = smoothstep(0.8,0.25, length(uv-0.5));
          vec3 col = vec3(0.92,0.86,1.0) * (0.4 + 0.6*n);
          col = mix(col, vec3(0.85,0.75,1.0), 0.5*vig);
          gl_FragColor = vec4(mix(vec3(0.0), col, intensity), intensity*0.85);
        }
      `;
      function compile(src, type){ const s = gl.createShader(type); gl.shaderSource(s,src); gl.compileShader(s); if(!gl.getShaderParameter(s,gl.COMPILE_STATUS)) throw gl.getShaderInfoLog(s); return s; }
      const sVert = compile(vs, gl.VERTEX_SHADER), sFrag = compile(fs, gl.FRAGMENT_SHADER);
      shaderProgram = gl.createProgram(); gl.attachShader(shaderProgram, sVert); gl.attachShader(shaderProgram, sFrag); gl.linkProgram(shaderProgram);
      if(!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) throw gl.getProgramInfoLog(shaderProgram);
      quadVBO = gl.createBuffer(); gl.bindBuffer(gl.ARRAY_BUFFER, quadVBO);
      gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([-1,-1, 1,-1, -1,1, 1,1]), gl.STATIC_DRAW);
      shaderReady = true; showLoading(false); resolve();
    } catch(err){
      showLoading(false); shaderReady=false; gl=null; console.warn('Shader init failed',err); reject(err);
    }
  });
}

function renderShader(delta){
  if(!shaderReady || !gl || !shaderActive) return;
  shaderUniforms.time += delta;
  gl.viewport(0,0,glCanvas.width,glCanvas.height);
  gl.clearColor(0,0,0,0); gl.clear(gl.COLOR_BUFFER_BIT);
  gl.useProgram(shaderProgram);
  const aPos = gl.getAttribLocation(shaderProgram,'aPos');
  gl.bindBuffer(gl.ARRAY_BUFFER, quadVBO);
  gl.enableVertexAttribArray(aPos); gl.vertexAttribPointer(aPos,2,gl.FLOAT,false,0,0);
  gl.uniform1f(gl.getUniformLocation(shaderProgram,'time'), shaderUniforms.time);
  gl.uniform1f(gl.getUniformLocation(shaderProgram,'intensity'), shaderUniforms.intensity);
  gl.uniform1f(gl.getUniformLocation(shaderProgram,'noiseScale'), shaderUniforms.noiseScale);
  gl.uniform2f(gl.getUniformLocation(shaderProgram,'resolution'), shaderUniforms.resolution[0], shaderUniforms.resolution[1]);
  gl.drawArrays(gl.TRIANGLE_STRIP,0,4);
}

// Hook UI for reset & shader toggle & sliders
const resetBtn = document.getElementById('resetBtn');
const shaderToggle = document.getElementById('shaderToggle');
const shaderControls = document.getElementById('shaderControls');
const shaderIntensitySlider = document.getElementById('shaderIntensity');
const noiseScaleSlider = document.getElementById('noiseScale');
const shaderIntVal = document.getElementById('shaderIntVal');
const noiseVal = document.getElementById('noiseVal');
// FPS UI hookup
fpsDisplayEl = document.getElementById('fpsVal');
maxFpsSliderEl = document.getElementById('maxFps');
maxFpsValEl = document.getElementById('maxFpsVal');
if(maxFpsSliderEl){
  maxFps = parseInt(maxFpsSliderEl.value || 60);
  maxFpsValEl.textContent = maxFps;
  maxFpsSliderEl.addEventListener('input', (e) => {
    maxFps = parseInt(e.target.value);
    if(maxFpsValEl) maxFpsValEl.textContent = maxFps;
  });
}

resetBtn.addEventListener('click', ()=>{ initGrid(resolutionSelect.value); particles=[]; lightnings=[]; vx.fill(0); vy.fill(0); density.fill(0); statusEl.textContent='Simulation reset'; });

shaderToggle.addEventListener('click', async ()=>{
  shaderActive = !shaderActive;
  shaderToggle.classList.toggle('on', shaderActive);
  shaderToggle.textContent = shaderActive ? 'Shader: On' : 'Shader: Off';
  shaderControls.style.display = shaderActive ? 'flex' : 'none';
  if(shaderActive){
    // init if needed
    if(!shaderReady){
      showLoading(true);
      try{ await initWebGLShader(); } catch(e){ shaderActive=false; shaderToggle.classList.remove('on'); shaderToggle.textContent='Shader: Off'; shaderControls.style.display='none'; return; }
    }
    glCanvas.style.display='block'; resizeGlCanvas();
  } else {
    glCanvas.style.display='none';
  }
});

shaderIntensitySlider.addEventListener('input',(e)=>{ shaderUniforms.intensity=parseFloat(e.target.value); shaderIntVal.textContent=shaderUniforms.intensity; });
noiseScaleSlider.addEventListener('input',(e)=>{ shaderUniforms.noiseScale=parseFloat(e.target.value); noiseVal.textContent=shaderUniforms.noiseScale; });

// integrate shader render into animation loop with FPS cap
let lastTimeForShader = performance.now();
let lastFrameTime = performance.now();
function animate(timestamp){
  if(!running) return;
  // rAF provides timestamp; fallback to performance.now()
  const now = timestamp || performance.now();

  // enforce max FPS cap by skipping frames if needed
  const minFrameInterval = 1000 / maxFps;
  if (now - lastFrameTime < minFrameInterval) {
    // still update rAF but don't run a heavy frame
    requestAnimationFrame(animate);
    return;
  }
  const dt = (now - lastTimeForShader) * 0.001;
  lastTimeForShader = now;
  lastFrameTime = now;

  // FPS measurement (smoothed)
  framesThisSecond++;
  if (now - fpsLastTime >= 1000) {
    fps = framesThisSecond;
    framesThisSecond = 0;
    fpsLastTime += 1000;
    // smooth rapidly changing FPS
    fpsSmoothed = fpsSmoothed ? fpsSmoothed * 0.85 + fps * 0.15 : fps;
    if (fpsDisplayEl) fpsDisplayEl.textContent = Math.round(fpsSmoothed);
  }

  step();
  render();
  if(shaderActive && shaderReady){
    renderShader(dt);
  }
  optimizationTick(now);
  requestAnimationFrame(animate);
}

// Optimization engine: adaptive performance tuning
let optLastCheck = performance.now();
function optimizationTick(now){
  if (now - optLastCheck < 2000) return;
  optLastCheck = now;
  const target = maxFps;
  if (fpsSmoothed && fpsSmoothed < target * 0.6) {
    // reduce load: trim droplets, lower shader intensity, lower maxFps
    if (!disableMaxDropletCap) {
      const cap = Math.max(120, Math.floor(maxDroplets * 0.8));
      if (particles.length > cap) particles.splice(0, particles.length - cap);
      maxDroplets = cap; if (maxDropletsSlider) { maxDropletsSlider.value = cap; maxDropletsVal.textContent = cap; }
    }
    shaderUniforms.intensity = Math.max(0.3, shaderUniforms.intensity * 0.85);
    if (shaderActive) { shaderIntensitySlider.value = shaderUniforms.intensity; shaderIntVal.textContent = shaderUniforms.intensity.toFixed(2); }
    maxFps = Math.max(30, Math.floor(maxFps * 0.9)); if (maxFpsSliderEl) { maxFpsSliderEl.value = maxFps; maxFpsValEl.textContent = maxFps; }
  } else if (fpsSmoothed && fpsSmoothed > target * 0.95) {
    // cautiously increase visual quality
    shaderUniforms.intensity = Math.min(1.0, shaderUniforms.intensity * 1.04);
    if (shaderActive) { shaderIntensitySlider.value = shaderUniforms.intensity; shaderIntVal.textContent = shaderUniforms.intensity.toFixed(2); }
    maxFps = Math.min(120, Math.floor(maxFps * 1.02)); if (maxFpsSliderEl) { maxFpsSliderEl.value = maxFps; maxFpsValEl.textContent = maxFps; }
  }
}

// start loop via rAF for timestamped animation
lastLightningTime = 0;
requestAnimationFrame(animate);

// Animation loop
// Clean up on unload
window.addEventListener('beforeunload', () => {
  running = false;
  canvas.removeEventListener('mousemove', onStart);
  canvas.removeEventListener('mousemove', onMove);
  canvas.removeEventListener('mouseup', onEnd);
  canvas.removeEventListener('touchstart', onStart);
  canvas.removeEventListener('touchmove', onMove);
  canvas.removeEventListener('mouseup', onEnd);
  canvas.removeEventListener('touchend', onEnd);
  canvas.removeEventListener('touchcancel', onEnd);
});

// Hook up resolution selector and shadow slider
const resolutionSelect = document.getElementById('resolutionSelect');
// shadow rays controls removed from UI and logic

resolutionSelect.addEventListener('change', (e) => {
  const val = e.target.value;
  // stop loop, re-init grid, and preserve running state
  running = false;
  initGrid(val);
  // clear particles/lightnings to avoid mismatches
  particles = [];
  lightnings = [];
  // update UI texts
  statusEl.textContent = 'Resolution changed — ready';
  // restart animation if it was running before
  if (pauseBtn.textContent === 'Pause') {
    running = true;
    requestAnimationFrame(animate);
  }
});

/* shadow rays slider removed */

// New: fullscreen button handling
const fullscreenBtn = document.getElementById('fullscreenBtn');
const zoomSlider = document.getElementById('zoomSlider');
const camXSlider = document.getElementById('camXSlider');
const viewW = document.getElementById('viewW');
const viewH = document.getElementById('viewH');
const fullscreenLandscapeBtn = document.getElementById('fullscreenLandscapeBtn');

fullscreenBtn.addEventListener('click', async ()=>{
  try{
    await canvas.requestFullscreen();
    document.body.style.background = 'black';
  }catch(e){ /* ignore */ }
});

// Landscape fullscreen with orientation lock where supported
fullscreenLandscapeBtn.addEventListener('click', async ()=>{
  try{
    await canvas.requestFullscreen();
    if (screen.orientation && screen.orientation.lock) {
      try { await screen.orientation.lock('landscape'); } catch(e){}
    }
    document.body.style.background = 'black';
  }catch(e){ /* ignore */ }
});

zoomSlider.addEventListener('input',(e)=>{ zoom = parseFloat(e.target.value); });
camXSlider.addEventListener('input',(e)=>{ cameraX = parseFloat(e.target.value) * (SIZE*0.01); });

function applyViewSize(w,h){
  canvas.style.width = w+'px'; canvas.style.height = h+'px';
  glCanvas.style.width = w+'px'; glCanvas.style.height = h+'px';
}
viewW.addEventListener('input',(e)=>{ applyViewSize(parseInt(e.target.value), parseInt(viewH.value)); });
viewH.addEventListener('input',(e)=>{ applyViewSize(parseInt(viewW.value), parseInt(e.target.value)); });
applyViewSize(512,512);

// New: precipitation controls
maxDropletsSlider.addEventListener('input',(e)=>{ maxDroplets=parseInt(e.target.value); maxDropletsVal.textContent=maxDroplets; });
baseTempSlider.addEventListener('input',(e)=>{ 
  const newBase = parseFloat(e.target.value);
  const delta = newBase - baseTemperature;
  baseTemperature = newBase; baseTempVal.textContent = baseTemperature;
  // shift current temperatures by delta
  for(let i=0;i<N*N;i++) temperature[i] += delta;
});

</script>

</body>
</html>